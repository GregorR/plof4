/*
 * The Plof base definitions. This file gets you from the grammar defined by
 * fythecore to a functional Plof grammar.
 *
 * Copyright (C) 2007-2011 Gregor Richards
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

grammar {
    // End of statement can be either a semicolon or a newline (perhaps with line comments)
    EOS = White /;/ WhiteN => (Null)
    EOS = White /((\/\/[^\r\n]*)?\r*\n)/ WhiteN => (Null)
    EOS = White /()\}/ => (Null)

    // the base Plof grammar
    LanguageExpression = Plof => $0

    Plof = /plof/ WhiteN /\{/ WhiteN Plof.Statements /\}/ WhiteN => (Plof.Top $4)

    Plof.Statements = Plof.Statement => $0
    Plof.Statements = Plof.Statements Plof.Statement => (Seq $0 $1)

    Plof.Statement = Plof.Statement.Next EOS => $0
    Plof.Statement => Plof.Assign

    Plof.Semicolon = Plof.Semicolon.Next => $0
    Plof.Semicolon = Plof.Semicolon EOS Plof.Semicolon.Next => (Seq
        $0 $2
    )
    Plof.Semicolon => Plof.Assign

    Plof.Assign = Plof.Assign.Next => $0
    Plof.Assign = Plof.Assign.Next "="n Plof.Assign => (Plof.Assign $0 $2)
    Plof.Assign => Plof.Member

    Plof.Member = Plof.Member.Next => $0
    Plof.Member = Plof.Member "\."n Plof.Identifier => (Plof.Member $0 $2)
    Plof.Member => Plof.Primary
   
    Plof.Primary = Plof.Primary.Next => $0
    Plof.Primary = "var"n Plof.Identifier => (Plof.VarDecl $1)
    Plof.Primary = Plof.Identifier => (Plof.Var $0)
    Plof.Primary = "\("n Plof.Semicolon "\)" => $1
    Plof.Primary = LanguageExpression => $0
    Plof.Primary = /\$[0-9][0-9]*/ => $0 // for putting Plof into grammar

    Plof.Identifier = !Plof.Keyword /[A-Za-z_][A-Za-z0-9_]*/ Token White => $1

    Plof.Keyword = "let" => (Null)
    Plof.Keyword = "parent" => (Null)
    Plof.Keyword = "var" => (Null)
}

// Get Plof's global functions
fythe { (ReserveGlobal Plof.Globals 6) }
transforms {
    * {
        (Plof.Globals.GlobalScope)          => (Plof.Globals)
        (Plof.Globals.Integer)              => fythe { (IAdd (Plof.Globals) 1) }
        (Plof.Globals.Extend)               => fythe { (IAdd (Plof.Globals) 2) }
        (Plof.Globals.CombineDecls)         => fythe { (IAdd (Plof.Globals) 3) }
        (Plof.Globals.CombineObjs)          => fythe { (IAdd (Plof.Globals) 4) }
        (Plof.Globals.POHeader)             => fythe { (IAdd (Plof.Globals) 5) }
    }
}

// some global convenience functions for compiling Plof
fml {
    // variable contexts
    fun plofNewCtx(parent) {
        ctx = newtbl();
        ctx.parent = parent;
        ctx.varct = 0;
        ctx.vars = newtbl();
        ctx;
    }

    plofGlobalCtx = plofNewCtx(null);

    fun mlist(o, i) {
        fythe { (MList (MGet (Arg) 0 o) (MGet (Arg) 0 i)) };
    }

    // get a reference to the value of this variable
    fun plofGetVar(ctx, nm, depth) {
        if (ctx === plofGlobalCtx) {
            // things are more screwy at the global context
            obj("MGet", obj("Global"), obj("Plof.Globals.GlobalScope"), nm);

        } else if (mcontains(ctx.vars, 0, nm)) {
            ret = obj("Temp", 0);

            // begin wending our way to the top
            for (depth; depth > 0; depth = depth - 1) {
                ret = obj("Member", ret, 0);
            }

            // OK, it's at this depth
            ret = obj("Member", obj("Temp", 0), ctx.vars->(nm) + 1);

            ret;

        } else {
            // try the parent context
            plofGetVar(ctx.parent, nm, depth+1);

        }
    }

    // put a variable in this context, returning the getter for that variable
    fun plofSetVar(ctx, nm) {
        if (ctx !== plofGlobalCtx) {
            // actually might need to add it
            if (!mcontains(ctx.vars, 0, nm)) {
                // yup, add it
                ctx.vars->(nm) = ctx.varct;
                ctx.varct = ctx.varct + 1;
            }
        }

        plofGetVar(ctx, nm, 0);
    }

    // resolve all variable references in this AST node
    fun plofResolveVars(ctx, node) {
        if (length(node) == 0) {
            // just a primitive

        } else if (node[0] eq "Plof.Function") {
            // function definition, make a context for it
            sctx = plofNewCtx(ctx);

            // then recurse (FIXME: need to handle arguments, actually reserving space)
            node[0] = "Function";
            node[1] = plofResolveVars(sctx, node[1]);

        } else if (node[0] eq "Plof.Var") {
            // a variable reference
            node = plofGetVar(ctx, node[1], 0);

        } else if (node[0] eq "Plof.VarDecl") {
            // a variable declaration
            node = plofSetVar(ctx, node[1], lhs);

        } else {
            // all other cases
            for (i = 1; i < length(node); i = i + 1) {
                node[i] = plofResolveVars(ctx, node[i]);
            }

        }

        node;
    }

    // make the global scope legitimate
    minit(fytheGlobal(), fythe{(Plof.Globals.GlobalScope)});
}

transforms {
    Parsing => Plof.Optim
    Plof.Optim => Plof.Resolve
    Plof.Resolve => Plof.LHS
    Plof.LHS => Plof.Compile
    Plof.Compile => Plof.Finalize

    Plof.Resolve {
        (Plof.Top x) => fml {
            plofResolveVars(plofGlobalCtx, env@1.x);
        }
    }

    Plof.LHS {
        (Plof.Assign (MGet o i n) v) => (MSet o i n v)
        (Plof.Assign (Member o i) v) => (MemberSet o i v)
        (Plof.Assign (Plof.Member o n) v) => (Plof.MemberSet o n v)
    }

    Plof.Compile {
        (Plof.Integer x) => (Call (Member (Global) (Plof.Globals.Integer)) x)
        (Plof.Member x y) => (PO.Member x y)
        (Plof.MemberSet x y z) => (PO.MemberSet x y z)
        (Plof.Extend x y) => (Call (Member (Global) (Plof.Globals.Extend)) (Object x y))
        (Plof.CombineDecls x y) => (Call (Member (Global) (Plof.Globals.CombineDecls)) (Object x y))
        (Plof.CombineObjs x y) => (Call (Member (Global) (Plof.Globals.CombineObjs)) (Object x y))
    }
}

// integers
grammar {
    Plof.Primary = /-?[0-9]+/ Token WhiteN => (Plof.Integer (SToIntegerT $0))
}

// simple objects
grammar {
    Plof.Assign => Plof.Combine

    Plof.Assign = Plof.Assign.Next ":="n "\["n Plof.ObjDefs "\]" => (Plof.Extend $0 $3)

    Plof.Combine = Plof.Combine.Next => $0
    Plof.Combine = Plof.Combine ":"n "\["n Plof.ObjDefs "\]" => (Plof.CombineDecls $0 $3)
    Plof.Combien = Plof.Combine ":"n Plof.Combine.Next => (Plof.CombineObjs $0 $3)

    Plof.ObjDefs = WhiteN => (Object)
    Plof.ObjDefs = Plof.ObjDefs.Next => $0
    Plof.ObjDefs = Plof.ObjDefs EOS => $0
    Plof.ObjDefs = Plof.ObjDefs EOS Plof.ObjDefs.Next => (Concat $0 $2)
    Plof.ObjDefs => Plof.ObjDef

    Plof.ObjDef = Plof.Identifier "="n Plof.Assign => (Object $0 $2)
}

// implementations of global functions
fythe {
    // .Integer will be filled in properly later
    (MemberSet (Global) (Plof.Globals.Integer) (Function (Arg)))

    // extend is the easiest of the object nonsense
    (MemberSet (Global) (Plof.Globals.Extend) {fml{ fun() {
        for (temp(1) = 0; temp(1) < length(arg[1]); temp(1) = temp(1) + 2) {
            arg[0]@1->(arg[1][temp(1)]) = arg[1][temp(1)+1];
        }
    }; }})

    // ... yeah, I'll get to those other ones later :P

    // and the global object
    (TempSet 0 (New 2))
    (MInit (Temp 0) 1)
    (MSet (Global) (Plof.Globals.GlobalScope) Object (Temp 0))
    (MSet (Member (Global) (FML.Global)) 0 plofObject (Temp 0))
}
